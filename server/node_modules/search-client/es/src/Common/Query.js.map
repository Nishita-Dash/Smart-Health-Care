{"version":3,"file":"Query.js","sourceRoot":"","sources":["../../../src/Common/Query.ts"],"names":[],"mappings":"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","sourcesContent":["import moment from \"moment\";\r\n\r\nimport { CategorizationType } from \"./CategorizationType\";\r\nimport { OrderBy } from \"./OrderBy\";\r\nimport { SearchType } from \"./SearchType\";\r\nimport { Filter } from \"./Filter\";\r\nimport { QueryChangeSpecifications } from \"./QueryChangeSpecifications\";\r\nimport { ICategory } from '../Data/ICategory';\r\n\r\nexport interface IQuery {\r\n    /**\r\n     * Any string that you want to identify the client with. Can be used in the categories configuration and in the relevance tuning.\r\n     */\r\n    clientId?: string;\r\n\r\n    /**\r\n     * Used to specify whether categorize calls should always return all categories or just categories that has matches.\r\n     */\r\n    categorizationType?: CategorizationType;\r\n\r\n    /**\r\n     * Used to specify the start date-range.\r\n     */\r\n    dateFrom?: DateSpecification;\r\n\r\n    /**\r\n     * Used to specify the end date-range.\r\n     */\r\n    dateTo?: DateSpecification;\r\n\r\n    /**\r\n     * Use one of this query parameter to specify the filters to apply. Each filter should contain its group name\r\n     * followed by category names, representing complete hierarchy of the category. The names specified here is derived from category Name\r\n     * property and not its display name. When specifying multiple filters, separate them either by comma or semicolon.\r\n     * For example: &f=Authors|Sam;FileTypes|docx\r\n     * Note the above names are case sensitive.\r\n     */\r\n    filters?: Filter[];\r\n\r\n    /**\r\n     * Decides whether or not to request content to be generated in the response matches.\r\n     */\r\n    matchGenerateContent?: boolean;\r\n\r\n    /**\r\n     * Decides whether or not to request highlight-tags to be included in the generated the response matches.\r\n     *\r\n     * Note: Requires `matchGenerateContent` to be `true` to be effective.\r\n     */\r\n    matchGenerateContentHighlights?: boolean;\r\n\r\n    /**\r\n     * Decides whether or not to use the parent-grouping feature to group results.\r\n     */\r\n    matchGrouping?: boolean;\r\n\r\n    /**\r\n     * Decides which ordering algorithm to use.\r\n     */\r\n    matchOrderBy?: OrderBy;\r\n\r\n    /**\r\n     * The actual page to fetch. Expects a number >= 1.\r\n     */\r\n    matchPage?: number;\r\n\r\n    /**\r\n     * The number of results per page to fetch. Expects a number >= 1.\r\n     */\r\n    matchPageSize?: number;\r\n\r\n    /**\r\n     * The maximum number of query-suggestions to fetch.\r\n     */\r\n    maxSuggestions?: number;\r\n\r\n    /**\r\n     * The queryText that is to be used for autocomplete/find/categorize.\r\n     */\r\n    queryText?: string;\r\n\r\n    /**\r\n     * The type of search to perform.\r\n     */\r\n    searchType?: SearchType;\r\n\r\n    /**\r\n     * The UI language of the client (translates i.e. categories to the client language).\r\n     */\r\n    uiLanguageCode?: string;\r\n}\r\n/**\r\n * Represents a date-specification that can either be fixed or a delta from now.\r\n * If the date is a moment DurationInputObject we calculate the date in real-time when the fetch-call is executed.\r\n * Note that the value must be an object with properties and values. I.e. { M: -1 } // One month ago\r\n * See http://momentjs.com/docs/#/durations/.\r\n * Otherwise we assume that the value is a fixed value that the moment library can parse without any helping formatting\r\n * strings. See http://momentjs.com/docs/#/parsing/string/.\r\n */\r\nexport type DateSpecification =\r\n    | Date\r\n    | string\r\n    | number\r\n    | moment.DurationInputObject;\r\n\r\nexport class Query implements IQuery {\r\n    /**\r\n     * Any string that you want to identify the client with. Can be used in the categories configuration and in the relevance tuning.\r\n     */\r\n    public clientId?: string = \"web\";\r\n\r\n    /**\r\n     * Used to specify whether categorize calls should always return all categories or just categories that has matches.\r\n     */\r\n    public categorizationType?: CategorizationType =\r\n        CategorizationType.DocumentHitsOnly;\r\n\r\n    /**\r\n     * Used to specify the start date-range.\r\n     */\r\n    public dateFrom?: DateSpecification = null;\r\n\r\n    /**\r\n     * Used to specify the end date-range.\r\n     */\r\n    public dateTo?: DateSpecification = null;\r\n\r\n    /**\r\n     * Use one of this query parameter to specify the filters to apply. Each filter should contain its group name\r\n     * followed by category names, representing complete hierarchy of the category. The names specified here is derived from category Name\r\n     * property and not its display name. When specifying multiple filters, separate them either by comma or semicolon.\r\n     * For example: &f=Authors|Sam;FileTypes|docx\r\n     * Note the above names are case sensitive.\r\n     */\r\n    public filters?: Filter[] = [];\r\n\r\n    /**\r\n     * Decides whether or not to request content to be generated in the response matches.\r\n     */\r\n    public matchGenerateContent?: boolean = true;\r\n\r\n    /**\r\n     * Decides whether or not to request highlight-tags to be included in the generated the response matches.\r\n     *\r\n     * Note: Requires `matchGenerateContent` to be `true` to be effective.\r\n     */\r\n    public matchGenerateContentHighlights?: boolean = true;\r\n\r\n    /**\r\n     * Decides whether or not to use the parent-grouping feature to group results.\r\n     */\r\n    public matchGrouping?: boolean = true;\r\n\r\n    /**\r\n     * Decides which ordering algorithm to use.\r\n     */\r\n    public matchOrderBy?: OrderBy = OrderBy.Relevance;\r\n\r\n    /**\r\n     * The actual page to fetch. Expects a number >= 1.\r\n     */\r\n    public matchPage?: number = 1;\r\n\r\n    /**\r\n     * The number of results per page to fetch. Expects a number >= 1.\r\n     */\r\n    public matchPageSize?: number = 10;\r\n\r\n    /**\r\n     * The maximum number of query-suggestions to fetch.\r\n     */\r\n    public maxSuggestions?: number = 10;\r\n\r\n    /**\r\n     * The queryText that is to be used for autocomplete/find/categorize.\r\n     */\r\n    public queryText?: string = \"\";\r\n\r\n    /**\r\n     * The type of search to perform.\r\n     */\r\n    public searchType?: SearchType = SearchType.Keywords;\r\n\r\n    /**\r\n     * The UI language of the client (translates i.e. categories to the client language).\r\n     */\r\n    public uiLanguageCode?: string = \"\";\r\n\r\n    /**\r\n     * Instantiates a Query object, based on Query defaults and the overrides provided as a param.\r\n     *\r\n     * @param query - The Query object with override values.\r\n     */\r\n    constructor(query: IQuery = {} as IQuery) {\r\n        if (\r\n            query.categorizationType &&\r\n            CategorizationType[query.categorizationType] === undefined\r\n        ) {\r\n            throw new Error(\r\n                `Illegal CategorizationType value: ${query.categorizationType}`\r\n            );\r\n        }\r\n        if (query.matchOrderBy && OrderBy[query.matchOrderBy] === undefined) {\r\n            throw new Error(`Illegal OrderBy value: ${query.matchOrderBy}`);\r\n        }\r\n        if (query.searchType && SearchType[query.searchType] === undefined) {\r\n            throw new Error(`Illegal SearchType value: ${query.searchType}`);\r\n        }\r\n        Object.assign(this, query);\r\n    }\r\n\r\n    public equals?(\r\n        query: IQuery,\r\n        queryChangeSpecs?: QueryChangeSpecifications\r\n    ): boolean {\r\n        for (let prop in (query as Query)) {\r\n            if (\r\n                query.hasOwnProperty(prop) &&\r\n                (queryChangeSpecs\r\n                    ? queryChangeSpecs & QueryChangeSpecifications[prop]\r\n                    : true)\r\n            ) {\r\n                // Special handling for string based values\r\n                if (typeof this[prop] === \"string\") {\r\n                    if (\r\n                        // tslint:disable-next-line:triple-equals\r\n                        (this[prop] as string).trim() !=\r\n                        (query[prop] as string).trim()\r\n                    ) {\r\n                        return false;\r\n                    }\r\n                    continue;\r\n                }\r\n                // tslint:disable-next-line:triple-equals\r\n                if (this[prop] != query[prop]) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public filterId(filter: string[] | ICategory | Filter): string[] {\r\n        let id: string[];\r\n        if (Array.isArray(filter)) {\r\n            id = filter;\r\n        } else if (filter instanceof Filter) {\r\n            id = filter.category.categoryName;\r\n        } else {\r\n            id = filter.categoryName;\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public filterIndex(filter: string[]): number {\r\n        const filterString = filter.join(\"|\");\r\n        return this.filters.findIndex(f => f.category.categoryName.join(\"|\") === filterString);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the passed argument is a filter.\r\n     * Typically used to visually indicate that a category is also a filter.\r\n     */\r\n    public isFilter(category: string[] | ICategory | Filter): boolean {\r\n        const item = this.filterId(category);\r\n        return item ? this.filterIndex(item) !== -1 : false;\r\n    }\r\n\r\n    /**\r\n     * Checks whether any child-node of the given category has a filter defined for it.\r\n     * Typically used to visually show in the tree that a child-node has an active filter.\r\n     */\r\n    public hasChildFilter(category: string[] | ICategory): boolean {\r\n        const item = this.filterId(category);\r\n        if (!item || this.filterIndex(item) !== -1) {\r\n            return false;\r\n        }\r\n        const categoryPath = item.join(\"|\");\r\n        // tslint:disable-next-line:prefer-for-of\r\n        for (let i = 0; i < this.filters.length; i++) {\r\n            let filter = this.filters[i];\r\n            let filterPath = filter.category.categoryName.join(\"|\");\r\n            if (filterPath.indexOf(categoryPath) === 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n"]}