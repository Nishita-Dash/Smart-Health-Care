import moment from "moment";
import { CategorizationType } from "./CategorizationType";
import { OrderBy } from "./OrderBy";
import { SearchType } from "./SearchType";
import { Filter } from "./Filter";
import { QueryChangeSpecifications } from "./QueryChangeSpecifications";
import { ICategory } from '../Data/ICategory';
export interface IQuery {
    /**
     * Any string that you want to identify the client with. Can be used in the categories configuration and in the relevance tuning.
     */
    clientId?: string;
    /**
     * Used to specify whether categorize calls should always return all categories or just categories that has matches.
     */
    categorizationType?: CategorizationType;
    /**
     * Used to specify the start date-range.
     */
    dateFrom?: DateSpecification;
    /**
     * Used to specify the end date-range.
     */
    dateTo?: DateSpecification;
    /**
     * Use one of this query parameter to specify the filters to apply. Each filter should contain its group name
     * followed by category names, representing complete hierarchy of the category. The names specified here is derived from category Name
     * property and not its display name. When specifying multiple filters, separate them either by comma or semicolon.
     * For example: &f=Authors|Sam;FileTypes|docx
     * Note the above names are case sensitive.
     */
    filters?: Filter[];
    /**
     * Decides whether or not to request content to be generated in the response matches.
     */
    matchGenerateContent?: boolean;
    /**
     * Decides whether or not to request highlight-tags to be included in the generated the response matches.
     *
     * Note: Requires `matchGenerateContent` to be `true` to be effective.
     */
    matchGenerateContentHighlights?: boolean;
    /**
     * Decides whether or not to use the parent-grouping feature to group results.
     */
    matchGrouping?: boolean;
    /**
     * Decides which ordering algorithm to use.
     */
    matchOrderBy?: OrderBy;
    /**
     * The actual page to fetch. Expects a number >= 1.
     */
    matchPage?: number;
    /**
     * The number of results per page to fetch. Expects a number >= 1.
     */
    matchPageSize?: number;
    /**
     * The maximum number of query-suggestions to fetch.
     */
    maxSuggestions?: number;
    /**
     * The queryText that is to be used for autocomplete/find/categorize.
     */
    queryText?: string;
    /**
     * The type of search to perform.
     */
    searchType?: SearchType;
    /**
     * The UI language of the client (translates i.e. categories to the client language).
     */
    uiLanguageCode?: string;
}
/**
 * Represents a date-specification that can either be fixed or a delta from now.
 * If the date is a moment DurationInputObject we calculate the date in real-time when the fetch-call is executed.
 * Note that the value must be an object with properties and values. I.e. { M: -1 } // One month ago
 * See http://momentjs.com/docs/#/durations/.
 * Otherwise we assume that the value is a fixed value that the moment library can parse without any helping formatting
 * strings. See http://momentjs.com/docs/#/parsing/string/.
 */
export declare type DateSpecification = Date | string | number | moment.DurationInputObject;
export declare class Query implements IQuery {
    /**
     * Any string that you want to identify the client with. Can be used in the categories configuration and in the relevance tuning.
     */
    clientId?: string;
    /**
     * Used to specify whether categorize calls should always return all categories or just categories that has matches.
     */
    categorizationType?: CategorizationType;
    /**
     * Used to specify the start date-range.
     */
    dateFrom?: DateSpecification;
    /**
     * Used to specify the end date-range.
     */
    dateTo?: DateSpecification;
    /**
     * Use one of this query parameter to specify the filters to apply. Each filter should contain its group name
     * followed by category names, representing complete hierarchy of the category. The names specified here is derived from category Name
     * property and not its display name. When specifying multiple filters, separate them either by comma or semicolon.
     * For example: &f=Authors|Sam;FileTypes|docx
     * Note the above names are case sensitive.
     */
    filters?: Filter[];
    /**
     * Decides whether or not to request content to be generated in the response matches.
     */
    matchGenerateContent?: boolean;
    /**
     * Decides whether or not to request highlight-tags to be included in the generated the response matches.
     *
     * Note: Requires `matchGenerateContent` to be `true` to be effective.
     */
    matchGenerateContentHighlights?: boolean;
    /**
     * Decides whether or not to use the parent-grouping feature to group results.
     */
    matchGrouping?: boolean;
    /**
     * Decides which ordering algorithm to use.
     */
    matchOrderBy?: OrderBy;
    /**
     * The actual page to fetch. Expects a number >= 1.
     */
    matchPage?: number;
    /**
     * The number of results per page to fetch. Expects a number >= 1.
     */
    matchPageSize?: number;
    /**
     * The maximum number of query-suggestions to fetch.
     */
    maxSuggestions?: number;
    /**
     * The queryText that is to be used for autocomplete/find/categorize.
     */
    queryText?: string;
    /**
     * The type of search to perform.
     */
    searchType?: SearchType;
    /**
     * The UI language of the client (translates i.e. categories to the client language).
     */
    uiLanguageCode?: string;
    /**
     * Instantiates a Query object, based on Query defaults and the overrides provided as a param.
     *
     * @param query - The Query object with override values.
     */
    constructor(query?: IQuery);
    equals?(query: IQuery, queryChangeSpecs?: QueryChangeSpecifications): boolean;
    filterId(filter: string[] | ICategory | Filter): string[];
    filterIndex(filter: string[]): number;
    /**
     * Returns true if the passed argument is a filter.
     * Typically used to visually indicate that a category is also a filter.
     */
    isFilter(category: string[] | ICategory | Filter): boolean;
    /**
     * Checks whether any child-node of the given category has a filter defined for it.
     * Typically used to visually show in the tree that a child-node has an active filter.
     */
    hasChildFilter(category: string[] | ICategory): boolean;
}
