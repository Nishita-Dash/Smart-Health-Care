import { CategorizationType } from "./CategorizationType";
import { OrderBy } from "./OrderBy";
import { SearchType } from "./SearchType";
import { Filter } from "./Filter";
import { QueryChangeSpecifications } from "./QueryChangeSpecifications";
var Query = /** @class */ (function () {
    /**
     * Instantiates a Query object, based on Query defaults and the overrides provided as a param.
     *
     * @param query - The Query object with override values.
     */
    function Query(query) {
        if (query === void 0) { query = {}; }
        /**
         * Any string that you want to identify the client with. Can be used in the categories configuration and in the relevance tuning.
         */
        this.clientId = "web";
        /**
         * Used to specify whether categorize calls should always return all categories or just categories that has matches.
         */
        this.categorizationType = CategorizationType.DocumentHitsOnly;
        /**
         * Used to specify the start date-range.
         */
        this.dateFrom = null;
        /**
         * Used to specify the end date-range.
         */
        this.dateTo = null;
        /**
         * Use one of this query parameter to specify the filters to apply. Each filter should contain its group name
         * followed by category names, representing complete hierarchy of the category. The names specified here is derived from category Name
         * property and not its display name. When specifying multiple filters, separate them either by comma or semicolon.
         * For example: &f=Authors|Sam;FileTypes|docx
         * Note the above names are case sensitive.
         */
        this.filters = [];
        /**
         * Decides whether or not to request content to be generated in the response matches.
         */
        this.matchGenerateContent = true;
        /**
         * Decides whether or not to request highlight-tags to be included in the generated the response matches.
         *
         * Note: Requires `matchGenerateContent` to be `true` to be effective.
         */
        this.matchGenerateContentHighlights = true;
        /**
         * Decides whether or not to use the parent-grouping feature to group results.
         */
        this.matchGrouping = true;
        /**
         * Decides which ordering algorithm to use.
         */
        this.matchOrderBy = OrderBy.Relevance;
        /**
         * The actual page to fetch. Expects a number >= 1.
         */
        this.matchPage = 1;
        /**
         * The number of results per page to fetch. Expects a number >= 1.
         */
        this.matchPageSize = 10;
        /**
         * The maximum number of query-suggestions to fetch.
         */
        this.maxSuggestions = 10;
        /**
         * The queryText that is to be used for autocomplete/find/categorize.
         */
        this.queryText = "";
        /**
         * The type of search to perform.
         */
        this.searchType = SearchType.Keywords;
        /**
         * The UI language of the client (translates i.e. categories to the client language).
         */
        this.uiLanguageCode = "";
        if (query.categorizationType &&
            CategorizationType[query.categorizationType] === undefined) {
            throw new Error("Illegal CategorizationType value: " + query.categorizationType);
        }
        if (query.matchOrderBy && OrderBy[query.matchOrderBy] === undefined) {
            throw new Error("Illegal OrderBy value: " + query.matchOrderBy);
        }
        if (query.searchType && SearchType[query.searchType] === undefined) {
            throw new Error("Illegal SearchType value: " + query.searchType);
        }
        Object.assign(this, query);
    }
    Query.prototype.equals = function (query, queryChangeSpecs) {
        for (var prop in query) {
            if (query.hasOwnProperty(prop) &&
                (queryChangeSpecs
                    ? queryChangeSpecs & QueryChangeSpecifications[prop]
                    : true)) {
                // Special handling for string based values
                if (typeof this[prop] === "string") {
                    if (
                    // tslint:disable-next-line:triple-equals
                    this[prop].trim() !=
                        query[prop].trim()) {
                        return false;
                    }
                    continue;
                }
                // tslint:disable-next-line:triple-equals
                if (this[prop] != query[prop]) {
                    return false;
                }
            }
        }
        return true;
    };
    Query.prototype.filterId = function (filter) {
        var id;
        if (Array.isArray(filter)) {
            id = filter;
        }
        else if (filter instanceof Filter) {
            id = filter.category.categoryName;
        }
        else {
            id = filter.categoryName;
        }
        return id;
    };
    Query.prototype.filterIndex = function (filter) {
        var filterString = filter.join("|");
        return this.filters.findIndex(function (f) { return f.category.categoryName.join("|") === filterString; });
    };
    /**
     * Returns true if the passed argument is a filter.
     * Typically used to visually indicate that a category is also a filter.
     */
    Query.prototype.isFilter = function (category) {
        var item = this.filterId(category);
        return item ? this.filterIndex(item) !== -1 : false;
    };
    /**
     * Checks whether any child-node of the given category has a filter defined for it.
     * Typically used to visually show in the tree that a child-node has an active filter.
     */
    Query.prototype.hasChildFilter = function (category) {
        var item = this.filterId(category);
        if (!item || this.filterIndex(item) !== -1) {
            return false;
        }
        var categoryPath = item.join("|");
        // tslint:disable-next-line:prefer-for-of
        for (var i = 0; i < this.filters.length; i++) {
            var filter = this.filters[i];
            var filterPath = filter.category.categoryName.join("|");
            if (filterPath.indexOf(categoryPath) === 0) {
                return true;
            }
        }
        return false;
    };
    return Query;
}());
export { Query };
//# sourceMappingURL=Query.js.map