import { __extends } from "tslib";
import OIDC from "oidc-client";
import { BaseCall, Query } from "../Common";
import { AuthenticationSettings } from "./AuthenticationSettings";
import { AuthToken } from "./AuthToken";
/**
 * The OidcAuthentication service is a supporting feature for the other services.
 * Typically used via the [[SearchClient.constructor]] and by providing [[AuthenticationSettings]] settings in
 * the [[Settings.authentication]] property.
 *
 * The authentication system is based on OpenId Connect and needs an end-point to be configured supporting full
 * oidc flows. This service will be monitoring the token-value to see if it is either missing or
 * expired. When that happens a new token will be fetched from the oidc end-point.
 */
var OidcAuthentication = /** @class */ (function (_super) {
    __extends(OidcAuthentication, _super);
    /**
     * Creates an OidcAuthentication object that knows where to get the auth-token and when to refresh it.
     * @param settings - The settings for the authentication object.
     * @param auth - An object that controls the authentication for the lookups.
     */
    function OidcAuthentication(settings, auth, fetchMethod) {
        var _this = _super.call(this) || this;
        // prepare for super.init
        if (typeof settings === "string") {
            settings = { baseUrl: settings, type: "oidc" };
        }
        else {
            settings.type = "oidc";
        }
        settings = new AuthenticationSettings(settings);
        auth = auth || new AuthToken();
        _super.prototype.init.call(_this, settings, auth, fetchMethod);
        _this.oidcSettings = {
            authority: settings.url,
            client_id: settings.clientId,
            response_type: settings.responseType,
            scope: settings.scope,
            silent_redirect_uri: settings.silentRedirectUri,
            redirect_uri: settings.redirectUri,
            post_logout_redirect_uri: settings.postLogoutRedirectUri,
            automaticSilentRenew: true,
            loadUserInfo: true,
            userStore: new OIDC.WebStorageStateStore({ store: window.sessionStorage })
        };
        _this.user = new OIDC.UserManager(_this.oidcSettings);
        _this.user.events.addSilentRenewError(function () {
            _this.login(_this.user);
        });
        _this.user.events.addAccessTokenExpired(function () {
            _this.login(_this.user);
        });
        _this.user.events.addUserSignedOut(function () {
            _this.login(_this.user);
        });
        if (_this.settings.enableLogging) {
            OIDC.Log.logger = console;
            OIDC.Log.level = OIDC.Log.INFO;
        }
        if (settings.enabled) {
            // We authenticate immediately in order to have the token in place when the first calls come in.
            _this.update(null);
        }
        return _this;
    }
    OidcAuthentication.handleSilentSignin = function (responseMode) {
        var mgr = new OIDC.UserManager({ loadUserInfo: true, filterProtocolClaims: true, response_mode: responseMode, userStore: new OIDC.WebStorageStateStore({ store: window.sessionStorage }) });
        mgr.signinSilentCallback();
        mgr.clearStaleState();
    };
    OidcAuthentication.handleSigninRedirect = function (responseMode, callback) {
        var mgr = new OIDC.UserManager({ loadUserInfo: true, filterProtocolClaims: true, response_mode: responseMode, userStore: new OIDC.WebStorageStateStore({ store: window.sessionStorage }) });
        mgr.signinRedirectCallback().then(function (user) {
            callback(user.state);
            mgr.clearStaleState();
        });
    };
    /**
     * Fetches the authentication-token from the oidc server.
     * @param query - For the Authentication service this parameter is ignored.
     * @param suppressCallbacks - Set to true if you have defined callbacks, but somehow don't want them to be called.
     * @returns a promise that when resolved returns a jwt token.
     */
    OidcAuthentication.prototype.fetch = function (query, suppressCallbacks) {
        var _this = this;
        if (query === void 0) { query = new Query(); }
        if (suppressCallbacks === void 0) { suppressCallbacks = false; }
        var reqInit = this.requestObject(false);
        if (this.cbRequest(suppressCallbacks, this.settings.url, reqInit)) {
            return this.user.getUser().then(function (user) {
                if (!user) {
                    _this.login(_this.user);
                }
                else {
                    // Update the token
                    _this.auth.tokenResolver = function () {
                        var oidcKey = "oidc.user:" + _this.oidcSettings.authority + ":" + _this.oidcSettings.client_id;
                        return JSON.parse(window.sessionStorage.getItem(oidcKey)).access_token;
                    };
                    _this.cbSuccess(suppressCallbacks, _this.auth.authenticationToken, _this.settings.url, reqInit);
                    return user.access_token;
                }
            }).catch(function (error) {
                _this.cbError(suppressCallbacks, error, _this.settings.url, reqInit);
                throw error;
            });
        }
        else {
            return Promise.resolve(null);
        }
    };
    /**
     * Call the service, but take into account deferredUpdates.
     *
     * @param query The query object to create the fetch for.
     * @param delay A delay for when to execute the update, in milliseconds. Defaults to undefined.
     */
    OidcAuthentication.prototype.update = function (query, delay) {
        var _this = this;
        if (this.deferUpdate) {
            // Save the query, so that when the deferUpdate is again false we can then execute it.
            this.deferredQuery = query;
        }
        else {
            // In case this action is triggered when a delayed execution is already pending, clear that pending timeout.
            clearTimeout(this.delay);
            if (delay > 0) {
                // Set up the delay
                this.delay = setTimeout(function () {
                    var fetchPromise = _this.fetch(query);
                    if (fetchPromise) {
                        fetchPromise.catch(function (error) { return Promise.resolve(null); });
                    }
                }, delay);
            }
            else {
                var fetchPromise = this.fetch(query);
                if (fetchPromise) {
                    fetchPromise.catch(function (error) { return Promise.resolve(null); });
                }
            }
        }
    };
    OidcAuthentication.prototype.login = function (userManager) {
        userManager.createSigninRequest({ data: { currentUrl: window.location.href } })
            .then(function (response) {
            window.location.href = response.url;
        });
    };
    return OidcAuthentication;
}(BaseCall));
export { OidcAuthentication };
//# sourceMappingURL=OidcAuthentication.js.map