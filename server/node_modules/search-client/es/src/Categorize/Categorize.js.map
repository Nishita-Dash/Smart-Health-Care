{"version":3,"file":"Categorize.js","sourceRoot":"","sources":["../../../src/Categorize/Categorize.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC9C,OAAO,EACH,QAAQ,EAGR,MAAM,EAEN,KAAK,EAEL,SAAS,EAET,UAAU,GAIb,MAAM,WAAW,CAAC;AAEnB,OAAO,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AACtE,OAAO,EAAE,kBAAkB,EAAuB,MAAM,sBAAsB,CAAC;AAE/E;;;;;GAKG;AACH;IAAgC,8BAAqB;IAejD;;;;;OAKG;IACH,oBACI,QAAuC,EACvC,IAAgB,EAChB,WAAmB;QAHvB,YAKI,iBAAO,SAOV;QANG,yBAAyB;QACzB,QAAQ,GAAG,IAAI,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,GAAG,IAAI,IAAI,IAAI,SAAS,EAAE,CAAC;QAC/B,iBAAM,IAAI,aAAC,QAAQ,EAAE,IAAI,EAAE,WAAW,CAAC,CAAC;QACxC,qBAAqB;QACrB,KAAI,CAAC,cAAc,GAAG,IAAI,wBAAwB,EAAE,CAAC;;IACzD,CAAC;IAED;;;;;OAKG;IACI,0BAAK,GAAZ,UACI,KAA2B,EAC3B,iBAAkC;QAFtC,iBAgDC;QA/CG,sBAAA,EAAA,YAAoB,KAAK,EAAE;QAC3B,kCAAA,EAAA,yBAAkC;QAElC,IAAI,GAAG,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QAC/D,IAAI,OAAO,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QAEnC,IAAI,IAAI,CAAC,SAAS,CAAC,iBAAiB,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE;YACjD,IAAI,CAAC,UAAU,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC;YACnC,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,OAAO,CAAC;iBAChC,IAAI,CAAC,UAAC,QAAkB;gBACrB,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE;oBACd,MAAM,KAAK,CACJ,QAAQ,CAAC,MAAM,SACd,QAAQ,CAAC,UAAU,0BACF,GAAG,MAAG,CAC9B,CAAC;iBACL;gBACD,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;YAC3B,CAAC,CAAC;iBACD,IAAI,CAAC,UAAC,UAAuB;gBAC1B,KAAI,CAAC,UAAU,GAAG,UAAU,CAAC;gBAC7B,UAAU,GAAG,KAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;gBACtD,uGAAuG;gBACvG,IAAI,UAAU,CAAC,YAAY,IAAI,UAAU,CAAC,UAAU,KAAK,CAAC,EAAE;oBACjD,IAAA,sCAAY,EAAE,kCAAU,CAAgB;oBAC/C,IAAM,OAAO,GAAG;wBACZ,OAAO,EAAE,YAAY,IAAI,mBAAmB;wBAC5C,UAAU,YAAA;qBACb,CAAC;oBACF,KAAI,CAAC,SAAS,CAAC,iBAAiB,EAAE,OAAO,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;iBAC5D;gBACD,KAAI,CAAC,SAAS,CAAC,iBAAiB,EAAE,UAAU,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;gBAC5D,OAAO,UAAU,CAAC;YACtB,CAAC,CAAC;iBACD,KAAK,CAAC,UAAA,KAAK;gBACR,KAAI,CAAC,OAAO,CAAC,iBAAiB,EAAE,KAAK,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;gBACrD,MAAM,KAAK,CAAC;YAChB,CAAC,CAAC,CAAC;SACV;aAAM;YACH,6EAA6E;YAC7E,6DAA6D;YAC7D,KAAK;YACL,+DAA+D;YAC/D,KAAK;YACL,kEAAkE;YAClE,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SAChC;IACL,CAAC;IACM,2CAAsB,GAA7B,UAA8B,KAAa;QACvC,IAAI,IAAI,CAAC,YAAY,EAAE,EAAE;YACrB,IAAI,CAAC,SAAS,CACV,KAAK,EACL,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,EAC7C,IAAI,EACJ,IAAI,CACP,CAAC;SACL;IACL,CAAC;IAEM,8CAAyB,GAAhC,UACI,QAA4B,EAC5B,KAAa;QAEb,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,oBAAoB,EAAE,KAAK,CAAC,EAAE;YACjD,OAAO;SACV;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,yBAAyB,EAAE;YAClD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACtB;IACL,CAAC;IAEM,oCAAe,GAAtB,UAAuB,QAAgB,EAAE,KAAa;QAClD,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,KAAK,CAAC,EAAE;YACvC,OAAO;SACV;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,eAAe,EAAE;YACxC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACtB;IACL,CAAC;IAEM,oCAAe,GAAtB,UAAuB,QAA2B,EAAE,KAAa;QAC7D,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,KAAK,CAAC,EAAE;YACvC,OAAO;SACV;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,eAAe,EAAE;YACxC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACtB;IACL,CAAC;IAEM,kCAAa,GAApB,UAAqB,QAA2B,EAAE,KAAa;QAC3D,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE;YACrC,OAAO;SACV;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,aAAa,EAAE;YACtC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACtB;IACL,CAAC;IAEM,mCAAc,GAArB,UAAsB,QAAkB,EAAE,KAAa;QACnD,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,KAAK,CAAC,EAAE;YACtC,OAAO;SACV;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc,EAAE;YACvC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACtB;IACL,CAAC;IAEM,qCAAgB,GAAvB,UAAwB,QAAgB,EAAE,KAAa;QACnD,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,KAAK,CAAC,EAAE;YACxC,OAAO;SACV;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,WAAW,EAAE;YACpC,IACI,KAAK,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,MAAM;gBAC7B,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,oBAAoB,EAC7C;gBACE,IACI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,uBAAuB;oBAC9C,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,uBAAuB,CAAC,IAAI,CAC/C,KAAK,CAAC,SAAS,CAClB,EACH;oBACE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBACnB,OAAO;iBACV;qBAAM;oBACH,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,GAAG,CAAC,CAAC,EAAE;wBAC9C,IAAI,CAAC,MAAM,CACP,KAAK,EACL,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,CAC1C,CAAC;wBACF,OAAO;qBACV;iBACJ;aACJ;SACJ;QACD,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;IAEM,sCAAiB,GAAxB,UAAyB,QAAoB,EAAE,KAAa;QACxD,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,KAAK,CAAC,EAAE;YACzC,OAAO;SACV;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,iBAAiB,EAAE;YAC1C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACtB;IACL,CAAC;IAEM,0CAAqB,GAA5B,UAA6B,QAAgB,EAAE,KAAa;QACxD,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,gBAAgB,EAAE,KAAK,CAAC,EAAE;YAC7C,OAAO;SACV;QACD,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,qBAAqB,EAAE;YAC9C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACtB;IACL,CAAC;IAED;;;;;;;;;;;;;;;OAeG;IACI,yCAAoB,GAA3B,UAA4B,YAAkC;QAC1D,IAAI,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC;YACrC,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,YAAY,CAAC,YAAY,CAAC;QAChC,IAAI,MAAM,GAAa,EAAE,CAAC;QAC1B,IAAI,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5B,IAAI,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;QAEjD,IACI,CAAC,IAAI,CAAC,UAAU;YAChB,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM;YACvB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EACrC;YACE,OAAO,IAAI,CAAC;SACf;QAED,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CACnC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,OAAO,EAAhC,CAAgC,CACxC,CAAC;QAEF,IAAI,CAAC,KAAK,EAAE;YACR,OAAO,IAAI,CAAC;SACf;QAED,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QAE/B,IAAI,KAAK,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;YACzB,IAAA,0EAMH,EALG,4BAAW,EACX,YAIH,CAAC;YACF,IAAI,WAAW,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;gBACvC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;gBACpC,OAAO,IAAI,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;aAClC;SACJ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACI,iCAAY,GAAnB,UACI,YAAsB,EACtB,UAAwB;QAExB,UAAU,GAAG,UAAU,IAAI,IAAI,CAAC,UAAU,CAAC;QAC3C,IAAI,CAAC,UAAU,EAAE;YACb,OAAO,IAAI,CAAC;SACf;QACD,IAAI,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,SAAS,CACxC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC,CAAC,EAA1B,CAA0B,CAClC,CAAC;QACF,IAAI,UAAU,GAAG,CAAC,EAAE;YAChB,OAAO,IAAI,CAAC;SACf;QACD,IAAI,KAAK,GAAG,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QAC1C,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;YAC3B,OAAO,KAAK,CAAC;SAChB;QACD,IAAI,QAAQ,GAAG,IAAI,CAAC,wCAAwC,CACxD,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,EACrB,KAAK,CAAC,UAAU,CACnB,CAAC;QAEF,OAAO,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC;IAC1C,CAAC;IAED;;OAEG;IACK,8CAAyB,GAAjC,UAAkC,OAAiB,EAAE,IAAiB;QAAtE,iBAgEC;QA/DG,OAAO,CAAC,OAAO,CAAC,UAAA,CAAC;YACb,IAAI,CAAC,CAAC,MAAM,EAAE;gBACV,OAAO;aACV;YACD,IAAM,KAAK,GAAG,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC;YAC7C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;gBAC5B,IAAI,aAAa,GAAG,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC5D,IAAI,CAAC,KAAI,CAAC,YAAY,CAAC,aAAa,EAAE,IAAI,CAAC,EAAE;oBACzC,IAAI,WAAW,GAAG,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;oBAC7F,IAAI,mBAAmB,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;oBACrD,IAAI,CAAC,KAAK,CAAC,EAAE;wBACT,oBAAoB;wBACpB,IAAI,KAAK,GAAG;4BACR,WAAW,aAAA;4BACX,UAAU,EAAE,EAAE;4BACd,QAAQ,EAAE,KAAK;4BACf,IAAI,EAAE,aAAa,CAAC,CAAC,CAAC;yBACf,CAAC;wBACZ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBAC3B;yBAAM;wBACH,6BAA6B;wBAC7B,IAAI,QAAM,GAAG,KAAI,CAAC,YAAY,CAC1B,mBAAmB,EACnB,IAAI,CACP,CAAC;wBACF,IAAI,CAAC,QAAM,EAAE;4BACT,MAAM,KAAK,CACP,yEAAyE,CAC5E,CAAC;yBACL;wBACD,IAAI,QAAQ,GACR,CAAC,KAAK,KAAK,GAAG,CAAC;4BACX,CAAC,CAAC,sFAAsF;+CAE/E,EAAE,QAAQ,EAAE,EAAE,EAAE,WAAW,aAAA,EAAC,EAC5B,CAAC,CAAC,QAAQ,GACV,EAAE,KAAK,EAAE,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE,EAEtC,CAAC,CAAC,4BAA4B;4BAC3B;gCACG,YAAY,EAAE,aAAa;gCAC3B,QAAQ,EAAE,EAAE;gCACZ,KAAK,EAAE,CAAC;gCACR,QAAQ,EAAE,KAAK;gCACf,WAAW,aAAA;gCACX,IAAI,EAAE,aAAa,CAAC,CAAC,CAAC;6BACX,CAAC;wBAE1B,6DAA6D;wBAC7D,QAAM,CAAC,QAAQ,GAAG,IAAI,CAAC;wBAEvB,4CAA4C;wBAC5C,IAAI,CAAC,KAAK,CAAC,EAAE;4BACT,oBAAoB;4BACnB,QAAiB,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;yBAChD;6BAAM;4BACH,uBAAuB;4BACtB,QAAoB,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;yBACjD;qBACJ;iBACJ;aACJ;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,qCAAgB,GAAxB,UACI,UAAuB,EACvB,KAA2B;QAF/B,iBA6FC;QA3FG,sBAAA,EAAA,YAAoB,KAAK,EAAE;QAE3B,yBAAyB;QACzB,IAAI,IAAI,gBAAQ,UAAU,CAAE,CAAC;QAC7B,IAAI,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC;QACxD,IAAI,YAAY,EAAE;YACd,IACI,YAAY,CAAC,KAAK;gBAClB,YAAY,CAAC,KAAK,CAAC,OAAO;gBAC1B,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,YAAY,CAAC,KAAK,CAAC,QAAQ,EACnD;gBACE,wDAAwD;gBACxD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;aAC1D;YACD,IAAI,YAAY,CAAC,MAAM,IAAI,YAAY,CAAC,MAAM,CAAC,OAAO,EAAE;gBACpD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;aAC3D;YACD,IAAI,YAAY,CAAC,IAAI,IAAI,YAAY,CAAC,IAAI,CAAC,OAAO,EAAE;gBAChD,gBAAgB;gBAChB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;aACzD;YACD,IAAI,YAAY,CAAC,KAAK,IAAI,YAAY,CAAC,KAAK,CAAC,OAAO,EAAE;gBAClD,iCAAiC;gBACjC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,KAAK,CAAC,CAAC;aAChE;YACD,iDAAiD;SACpD;QACD,IAAM,aAAa,GAAa,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,MAAM,EAAR,CAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAEzF,0BAA0B;QAC1B,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAC,OAAe;YACzC,IAAI,KAAK,gBAAQ,OAAO,CAAE,CAAC;YAE3B,qDAAqD;YACrD,IAAI,oBAAoB,GAAG,aAAa,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,IAAI,EAA/E,CAA+E,CAAC,CAAC;YACtI,IAAI,KAAK,GAAG,oBAAoB,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,KAAK,CAAC,EAApC,CAAoC,CAAC,CAAC;YACjF,IAAI,KAAK,EAAE;gBACP,oEAAoE;gBACpE,OAAO,IAAI,CAAC;aACf;YAED,IAAI,aAAa,GAAG,KAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAC5D,IAAI,aAAa,EAAE;gBACf,IACI,aAAa,CAAC,KAAK;oBACnB,aAAa,CAAC,KAAK,CAAC,OAAO;oBAC3B,KAAK,CAAC,UAAU,CAAC,MAAM,IAAI,aAAa,CAAC,KAAK,CAAC,QAAQ,EACzD;oBACE,wDAAwD;oBACxD,KAAK,CAAC,UAAU,GAAG,KAAI,CAAC,QAAQ,CAC5B,aAAa,EACb,KAAK,CAAC,UAAU,CACnB,CAAC;iBACL;gBACD,IAAI,aAAa,CAAC,MAAM,IAAI,aAAa,CAAC,MAAM,CAAC,OAAO,EAAE;oBACtD,KAAK,CAAC,UAAU,GAAG,KAAI,CAAC,SAAS,CAC7B,aAAa,EACb,KAAK,CAAC,UAAU,CACnB,CAAC;iBACL;gBACD,IAAI,aAAa,CAAC,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE;oBAClD,gBAAgB;oBAChB,KAAK,CAAC,UAAU,GAAG,KAAI,CAAC,OAAO,CAC3B,aAAa,EACb,KAAK,CAAC,UAAU,CACnB,CAAC;iBACL;gBACD,IAAI,aAAa,CAAC,KAAK,IAAI,aAAa,CAAC,KAAK,CAAC,OAAO,EAAE;oBACpD,iCAAiC;oBACjC,KAAK,CAAC,UAAU,GAAG,KAAI,CAAC,QAAQ,CAC5B,KAAK,CAAC,UAAU,EAChB,aAAa,CAAC,KAAK,CACtB,CAAC;iBACL;gBACD,IAAI,aAAa,CAAC,QAAQ,KAAK,IAAI,EAAE;oBACjC,sDAAsD;oBACtD,KAAK,CAAC,QAAQ,GAAG,aAAa,CAAC,QAAQ,CAAC;iBAC3C;aACJ;YACD,IAAI,KAAK,CAAC,UAAU,IAAI,KAAK,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;gBACjD,KAAK,CAAC,UAAU,GAAG,KAAI,CAAC,aAAa,CAAC,KAAK,CAAC,UAAU,EAAE,oBAAoB,EAAE,CAAC,CAAC,CAAC,CAAC,8CAA8C;aACnI;YACD,IAAI,CAAC,CAAC,KAAK,CAAC,UAAU,IAAI,KAAK,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC,IAAI,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;gBACzF,sFAAsF;gBACtF,OAAO,IAAI,CAAC;aACf;YACD,OAAO,KAAK,CAAC;QACjB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,IAAI,EAA7B,CAA6B,CAAC,CAAC;QAChE,IAAI,CAAC,yBAAyB,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACpD,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,kCAAa,GAArB,UAAsB,UAAuB,EAAE,aAAuB,EAAE,KAAa;QAArF,iBAsEC;QArEG,6BAA6B;QAC7B,IAAI,IAAI,kBAAO,UAAU,CAAC,CAAC;QAC3B,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,UAAC,UAAqB;YAClC,IAAI,QAAQ,gBAAQ,UAAU,CAAE,CAAC;YAEjC,qDAAqD;YACrD,IAAI,uBAAuB,GAAG,aAAa,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,GAAG,KAAK,IAAI,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,KAAK,QAAQ,CAAC,IAAI,EAA1F,CAA0F,CAAC,CAAC;YACpJ,IAAI,uBAAuB,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,KAAK,KAAK,GAAG,CAAC,EAA5C,CAA4C,CAAC,EAAE;gBACjF,0EAA0E;gBAC1E,OAAO,IAAI,CAAC;aACf;YAED,IAAI,QAAQ,CAAC,YAAY,IAAI,IAAI,EAAE;gBAC/B,OAAO,CAAC,IAAI,CAAC,gJAAgJ,EAAE,QAAQ,CAAC,CAAC;gBACzK,OAAO,IAAI,CAAC;aACf;YAED,IAAI,gBAAgB,GAAG,KAAI,CAAC,QAAQ,CAAC,aAAa,CAC9C,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,CAClC,CAAC;YACF,IAAI,gBAAgB,EAAE;gBAClB,IACI,gBAAgB,CAAC,KAAK;oBACtB,gBAAgB,CAAC,KAAK,CAAC,OAAO;oBAC9B,QAAQ,CAAC,QAAQ,CAAC,MAAM,IAAI,gBAAgB,CAAC,KAAK,CAAC,QAAQ,EAC7D;oBACE,QAAQ,CAAC,QAAQ,GAAG,KAAI,CAAC,QAAQ,CAC7B,gBAAgB,EAChB,QAAQ,CAAC,QAAQ,CACpB,CAAC;iBACL;gBACD,IACI,gBAAgB,CAAC,MAAM;oBACvB,gBAAgB,CAAC,MAAM,CAAC,OAAO,EACjC;oBACE,QAAQ,CAAC,QAAQ,GAAG,KAAI,CAAC,SAAS,CAC9B,gBAAgB,EAChB,QAAQ,CAAC,QAAQ,CACpB,CAAC;iBACL;gBACD,IAAI,gBAAgB,CAAC,IAAI,IAAI,gBAAgB,CAAC,IAAI,CAAC,OAAO,EAAE;oBACxD,QAAQ,CAAC,QAAQ,GAAG,KAAI,CAAC,OAAO,CAC5B,gBAAgB,EAChB,QAAQ,CAAC,QAAQ,CACpB,CAAC;iBACL;gBACD,IAAI,gBAAgB,CAAC,KAAK,IAAI,gBAAgB,CAAC,KAAK,CAAC,OAAO,EAAE;oBAC1D,QAAQ,CAAC,QAAQ,GAAG,KAAI,CAAC,QAAQ,CAC7B,QAAQ,CAAC,QAAQ,EACjB,gBAAgB,CAAC,KAAK,CACzB,CAAC;iBACL;gBACD,IAAI,gBAAgB,CAAC,QAAQ,KAAK,IAAI,EAAE;oBACpC,QAAQ,CAAC,QAAQ,GAAG,gBAAgB,CAAC,QAAQ,CAAC;iBACjD;aACJ;YACD,IAAI,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBACnD,QAAQ,CAAC,QAAQ,GAAG,KAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,EAAE,CAAC,CAAC;aACrF;YACD,IAAI,CAAC,CAAC,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,CAAC,IAAI,uBAAuB,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC9F,0FAA0F;gBAC1F,OAAO,IAAI,CAAC;aACf;YAED,OAAO,QAAQ,CAAC;QACpB,CAAC,CAAC,CAAC;QAEH,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,IAAI,EAA7B,CAA6B,CAAC,CAAC;QACvD,OAAO,IAAI,CAAC;IAChB,CAAC;IACO,6BAAQ,GAAhB,UACI,gBAAsC,EACtC,UAAe;QAEf,IAAI,eAAe,GAA6B,IAAI,GAAG,EAGpD,CAAC;QAEJ,IAAI,sBAAsB,GAAwB,IAAI,GAAG,EAGtD,CAAC;QAEJ,mEAAmE;QACnE,IAAI,UAAmB,CAAC;QACxB,KAAc,UAAU,EAAV,yBAAU,EAAV,wBAAU,EAAV,IAAU,EAAE;YAArB,IAAI,CAAC,mBAAA;YACN,IAAI,SAAS,GAAG,gBAAgB,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;YAC/D,IAAI,CAAC,SAAS,EAAE;gBACZ,SAAS;aACZ;YAED,UAAU,GAAG,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;YACvC,IAAI,OAAO,GAAc,UAAU;gBAC/B,CAAC,CAAE,CAAe;gBAClB,CAAC,CAAC;oBACI,YAAY,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;oBACtB,QAAQ,EAAG,CAAY,CAAC,UAAU;oBAClC,oHAAoH;oBACpH,mCAAmC;oBACnC,KAAK,EAAE,CAAC,CAAC;oBACT,WAAW,EAAE,CAAC,CAAC,WAAW;oBAC1B,QAAQ,EAAE,CAAC,CAAC,QAAQ;oBACpB,IAAI,EAAE,CAAC,CAAC,IAAI;iBACf,CAAC;YAER,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBACjC,eAAe,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;aAC7C;iBAAM;gBACH,IAAI,UAAU,GAAG,eAAe,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAChD,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACzB,eAAe,CAAC,GAAG,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;aAC9C;YACD,sBAAsB,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;SACxD;QAED,+BAA+B;QAC/B,OAAO,UAAU;aACZ,GAAG,CAAC,UAAA,CAAC;YACF,IAAI,WAAW,GAAG,sBAAsB,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;YAC5D,IAAI,CAAC,WAAW,EAAE;gBACd,cAAc;gBACd,OAAO,SAAS,CAAC;aACpB;YACD,IAAI,aAAa,GAAG,eAAe,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;YACrD,IAAI,CAAC,aAAa,EAAE;gBAChB,OAAO,CAAC,CAAC;aACZ;YACD,IACI,aAAa,CAAC,MAAM;gBACpB,gBAAgB,CAAC,KAAK,CAAC,gBAAgB,EACzC;gBACE,IAAI,WAAW,GAAG;oBACd,IAAI,EAAE,OAAK,WAAW,OAAI;oBAC1B,QAAQ,EAAE,aAAa;oBACvB,WAAW,aAAA;oBACX,QAAQ,EAAE,IAAI;oBACd,YAAY,EAAE,CAAC,OAAK,WAAW,OAAI,CAAC;iBAClC,CAAC;gBACP,IAAI,UAAU,EAAE;oBACX,WAAyB,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;iBACzC;gBAED,aAAa,CAAC,OAAO,CAAC,UAAA,CAAC;oBACnB,sBAAsB,CAAC,MAAM,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;gBACjD,CAAC,CAAC,CAAC;gBACH,OAAO,WAAW,CAAC;aACtB;iBAAM;gBACH,OAAO,CAAC,CAAC;aACZ;QACL,CAAC,CAAC;aACD,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,IAAI,EAA7B,CAA6B,CAAC,CAAC;IACpD,CAAC;IAEO,8BAAS,GAAjB,UACI,QAA8B,EAC9B,MAAW;QAEX,OAAO,MAAM,CAAC,MAAM,CAAC,UAAA,CAAC;YAClB,IAAI,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE;gBACvB,IAAI,SAAS,GACT,QAAQ,CAAC,MAAM,CAAC,SAAS,KAAK,SAAS,CAAC,WAAW;oBAC/C,CAAC,CAAC,CAAC,CAAC,WAAW;oBACf,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;gBACjB,OAAO,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aAChD;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,4BAAO,GAAf,UACI,gBAAsC,EACtC,UAAe;QAEf,4BAA4B;QAC5B,IAAI,SAAS,GAAG,IAAI,GAAG,EAA8B,CAAC;QACtD,KAAc,UAA2B,EAA3B,KAAA,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAA3B,cAA2B,EAA3B,IAA2B,EAAE;YAAtC,IAAI,CAAC,SAAA;YACN,SAAS,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;SACxB;QAED,IAAI,KAAK,GAAG,IAAI,KAAK,EAAK,CAAC;QAC3B,IAAI,aAAa,GAAG,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAClD,UAAA,CAAC,IAAI,OAAA,OAAO,CAAC,CAAC,KAAK,KAAK,QAAQ,EAA3B,CAA2B,CACnC,CAAC;QACF,IAAI,YAAY,GAAG,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CACjD,UAAA,CAAC,IAAI,OAAA,OAAO,CAAC,CAAC,KAAK,KAAK,QAAQ,EAA3B,CAA2B,CACnC,CAAC;QAEF,KAAc,UAAU,EAAV,yBAAU,EAAV,wBAAU,EAAV,IAAU,EAAE;YAArB,IAAI,CAAC,mBAAA;YACN,IAAI,KAAK,GAAG,KAAK,CAAC;YAClB,KAAuB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;gBAAjC,IAAI,UAAU,sBAAA;gBACf,IACI,UAAU,CAAC,KAAK;oBAChB,CAAC,UAAU,CAAC,SAAS,KAAK,SAAS,CAAC,WAAW;wBAC3C,CAAC,CAAC,CAAC,CAAC,WAAW;wBACf,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EACf;oBACE,IAAI,UAAU,GAAG,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBAC3C,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACnB,SAAS,CAAC,GAAG,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;oBACtC,KAAK,GAAG,IAAI,CAAC;oBACb,MAAM;iBACT;aACJ;YACD,IAAI,KAAK,EAAE;gBACP,SAAS;aACZ;YACD,KAAsB,UAAY,EAAZ,6BAAY,EAAZ,0BAAY,EAAZ,IAAY,EAAE;gBAA/B,IAAI,SAAS,qBAAA;gBACd,IACK,SAAS,CAAC,KAAgB,CAAC,IAAI,CAC5B,SAAS,CAAC,SAAS,KAAK,SAAS,CAAC,WAAW;oBACzC,CAAC,CAAC,CAAC,CAAC,WAAW;oBACf,CAAC,CAAC,CAAC,CAAC,IAAI,CACf,EACH;oBACE,IAAI,UAAU,GAAG,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBAC1C,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACnB,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;oBACrC,KAAK,GAAG,IAAI,CAAC;oBACb,MAAM;iBACT;aACJ;YACD,IAAI,CAAC,KAAK,EAAE;gBACR,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aACjB;SACJ;QAED,oBAAoB;QACpB,IAAI,UAAU,GAAG,IAAI,KAAK,EAAK,CAAC;QAChC,SAAS,CAAC,OAAO,CAAC,UAAC,EAAE,EAAE,CAAC;YACpB,IAAI,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE;gBACjB,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;gBACnC,OAAO;aACV;YACD,IAAI,GAAG,GAAG,IAAI,KAAK,EAAK,CAAC;YAEzB,QAAQ,CAAC,CAAC,UAAU,EAAE;gBAClB,KAAK,UAAU,CAAC,QAAQ;oBACpB,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;wBACf,IAAI,IAAI,GACJ,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,WAAW;4BACjC,CAAC,CAAC,CAAC,CAAC,WAAW;4BACf,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;wBACjB,IAAI,IAAI,GACJ,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,WAAW;4BACjC,CAAC,CAAC,CAAC,CAAC,WAAW;4BACf,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;wBACjB,OAAO,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClD,CAAC,CAAC,CAAC;oBACH,MAAM;gBAEV,KAAK,UAAU,CAAC,SAAS;oBACrB,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;wBACf,IAAI,IAAI,GACJ,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,WAAW;4BACjC,CAAC,CAAC,CAAC,CAAC,WAAW;4BACf,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;wBACjB,IAAI,IAAI,GACJ,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,WAAW;4BACjC,CAAC,CAAC,CAAC,CAAC,WAAW;4BACf,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;wBACjB,OAAO,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClD,CAAC,CAAC,CAAC;oBACH,MAAM;gBAEV,KAAK,UAAU,CAAC,QAAQ;oBACpB,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;wBAC/B,GAAG,GAAI,EAAkB,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;4BAChC,OAAO,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK;gCACpB,CAAC,CAAC,CAAC,CAAC;gCACJ,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK;oCACf,CAAC,CAAC,CAAC;oCACH,CAAC,CAAC,CAAC,CAAC;wBAChB,CAAC,CAAQ,CAAC;qBACb;yBAAM;wBACH,GAAG,GAAG,EAAE,CAAC;qBACZ;oBACD,MAAM;gBACV,KAAK,UAAU,CAAC,SAAS;oBACrB,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;wBAC/B,GAAG,GAAI,EAAkB,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;4BAChC,OAAO,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK;gCACpB,CAAC,CAAC,CAAC,CAAC;gCACJ,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK;oCACf,CAAC,CAAC,CAAC;oCACH,CAAC,CAAC,CAAC,CAAC;wBAChB,CAAC,CAAQ,CAAC;qBACb;yBAAM;wBACH,GAAG,GAAG,EAAE,CAAC;qBACZ;oBACD,MAAM;gBACV,KAAK,UAAU,CAAC,QAAQ,CAAC;gBACzB;oBACI,uBAAuB;oBACvB,GAAG,GAAG,EAAE,CAAC;aAChB;YAED,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,0CAA0C;QAC1C,OAAO,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEO,6BAAQ,GAAhB,UAAiB,KAAY,EAAE,KAA6B;QACxD,IAAI,IAAI,GAAG,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC;QAC7C,IAAI,EAAE,GAAG,IAAI,GAAG,KAAK,CAAC,QAAQ,CAAC;QAC/B,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;IACjC,CAAC;IAEO,6DAAwC,GAAhD,UACI,YAAsB,EACtB,UAAuB;QAEvB,IAAI,MAAM,GAAa,EAAE,CAAC;QAC1B,IAAI,IAAI,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACjC,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;QAE/C,IAAI,QAAQ,GAAG,UAAU,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,KAAK,EAA9B,CAA8B,CAAC,CAAC;QAEpE,IAAI,CAAC,QAAQ,EAAE;YACX,OAAO,IAAI,CAAC;SACf;QAED,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QAElC,IAAI,GAA8C,CAAC;QACnD,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YACnD,OAAO,IAAI,CAAC;SACf;QAED,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;YACjD,GAAG,GAAG,IAAI,CAAC,wCAAwC,CAC/C,IAAI,EACJ,QAAQ,CAAC,QAAQ,CACpB,CAAC;YACF,IAAI,CAAC,GAAG,EAAE;gBACN,OAAO;aACV;YACD,IAAI,GAAG,CAAC,WAAW,IAAI,GAAG,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC/C,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;aAC3C;SACJ;QAED,OAAO,EAAE,WAAW,EAAE,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;IAClE,CAAC;IACL,iBAAC;AAAD,CAAC,AA/xBD,CAAgC,QAAQ,GA+xBvC","sourcesContent":["import { AuthToken } from \"../Authentication\";\r\nimport {\r\n    BaseCall,\r\n    DateSpecification,\r\n    Fetch,\r\n    Filter,\r\n    IQuery,\r\n    Query,\r\n    SearchType,\r\n    MatchMode,\r\n    SortPartConfiguration,\r\n    SortMethod,\r\n    LimitPageConfiguration,\r\n    CategoryPresentation,\r\n    CategorizationType,\r\n} from \"../Common\";\r\nimport { ICategories, ICategory, IGroup } from \"../Data\";\r\nimport { CategorizeQueryConverter } from \"./CategorizeQueryConverter\";\r\nimport { CategorizeSettings, ICategorizeSettings } from \"./CategorizeSettings\";\r\n\r\n/**\r\n * The Categorize service queries the search-engine for which categories that any\r\n * search-matches for the same query will contain.\r\n *\r\n * It is normally used indirectly via the SearchClient class.\r\n */\r\nexport class Categorize extends BaseCall<ICategories> {\r\n    /**\r\n     * This represents the last categories that was received from the backend.\r\n     *\r\n     * Note: Normally these are only used internally. You *can* however\r\n     * populate these yourself, but if you are also executing fetches (which\r\n     * the SearchClient is often doing in the automatic mode) then the contents\r\n     * may be overwritten at any time.\r\n     */\r\n    public categories: ICategories;\r\n\r\n    public settings: ICategorizeSettings;\r\n\r\n    private queryConverter: CategorizeQueryConverter;\r\n\r\n    /**\r\n     * Creates a Categorize instance that handles fetching categories dependent on settings and query.\r\n     * Supports registering a callback in order to receive categories when they have been received.\r\n     * @param settings - The settings that define how the Categorize instance is to operate.\r\n     * @param auth - An object that handles the authentication.\r\n     */\r\n    constructor(\r\n        settings?: ICategorizeSettings | string,\r\n        auth?: AuthToken,\r\n        fetchMethod?: Fetch\r\n    ) {\r\n        super(); // dummy\r\n        // prepare for super.init\r\n        settings = new CategorizeSettings(settings);\r\n        auth = auth || new AuthToken();\r\n        super.init(settings, auth, fetchMethod);\r\n        // Set own this props\r\n        this.queryConverter = new CategorizeQueryConverter();\r\n    }\r\n\r\n    /**\r\n     * Fetches the search-result categories from the server.\r\n     * @param query - The query-object that controls which results that are to be returned.\r\n     * @param suppressCallbacks - Set to true if you have defined callbacks, but somehow don't want them to be called.\r\n     * @returns a promise that when resolved returns a Categories object.\r\n     */\r\n    public fetch(\r\n        query: IQuery = new Query(),\r\n        suppressCallbacks: boolean = false\r\n    ): Promise<ICategories> {\r\n        let url = this.queryConverter.getUrl(this.settings.url, query);\r\n        let reqInit = this.requestObject();\r\n\r\n        if (this.cbRequest(suppressCallbacks, url, reqInit)) {\r\n            this.fetchQuery = new Query(query);\r\n            return this.fetchMethod(url, reqInit)\r\n                .then((response: Response) => {\r\n                    if (!response.ok) {\r\n                        throw Error(\r\n                            `${response.status} ${\r\n                                response.statusText\r\n                            } for request url '${url}'`\r\n                        );\r\n                    }\r\n                    return response.json();\r\n                })\r\n                .then((categories: ICategories) => {\r\n                    this.categories = categories;\r\n                    categories = this.filterCategories(categories, query);\r\n                    // Handle situations where parsing was ok, but we have an error in the returned message from the server\r\n                    if (categories.errorMessage || categories.statusCode !== 0) {\r\n                        let  { errorMessage, statusCode } = categories;\r\n                        const warning = {\r\n                            message: errorMessage || \"Unspecified issue\",\r\n                            statusCode\r\n                        };\r\n                        this.cbWarning(suppressCallbacks, warning, url, reqInit);\r\n                    }\r\n                    this.cbSuccess(suppressCallbacks, categories, url, reqInit);\r\n                    return categories;\r\n                })\r\n                .catch(error => {\r\n                    this.cbError(suppressCallbacks, error, url, reqInit);\r\n                    throw error;\r\n                });\r\n        } else {\r\n            // TODO: When a fetch is stopped due to cbRequest returning false, should we:\r\n            // 1) Reject the promise (will then be returned as an error).\r\n            // or\r\n            // 2) Resolve the promise (will then be returned as a success).\r\n            // or\r\n            // 3) should we do something else (old code returned undefined...)\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n    public clientCategoriesUpdate(query: IQuery): void {\r\n        if (this.shouldUpdate()) {\r\n            this.cbSuccess(\r\n                false,\r\n                this.filterCategories(this.categories, query),\r\n                null,\r\n                null\r\n            );\r\n        }\r\n    }\r\n\r\n    public categorizationTypeChanged(\r\n        oldValue: CategorizationType,\r\n        query: IQuery\r\n    ): void {\r\n        if (!this.shouldUpdate(\"categorizationType\", query)) {\r\n            return;\r\n        }\r\n        if (this.settings.triggers.categorizationTypeChanged) {\r\n            this.update(query);\r\n        }\r\n    }\r\n\r\n    public clientIdChanged(oldValue: string, query: IQuery) {\r\n        if (!this.shouldUpdate(\"clientId\", query)) {\r\n            return;\r\n        }\r\n        if (this.settings.triggers.clientIdChanged) {\r\n            this.update(query);\r\n        }\r\n    }\r\n\r\n    public dateFromChanged(oldValue: DateSpecification, query: IQuery) {\r\n        if (!this.shouldUpdate(\"dateFrom\", query)) {\r\n            return;\r\n        }\r\n        if (this.settings.triggers.dateFromChanged) {\r\n            this.update(query);\r\n        }\r\n    }\r\n\r\n    public dateToChanged(oldValue: DateSpecification, query: IQuery) {\r\n        if (!this.shouldUpdate(\"dateTo\", query)) {\r\n            return;\r\n        }\r\n        if (this.settings.triggers.dateToChanged) {\r\n            this.update(query);\r\n        }\r\n    }\r\n\r\n    public filtersChanged(oldValue: Filter[], query: IQuery) {\r\n        if (!this.shouldUpdate(\"filters\", query)) {\r\n            return;\r\n        }\r\n        if (this.settings.triggers.filtersChanged) {\r\n            this.update(query);\r\n        }\r\n    }\r\n\r\n    public queryTextChanged(oldValue: string, query: IQuery) {\r\n        if (!this.shouldUpdate(\"queryText\", query)) {\r\n            return;\r\n        }\r\n        if (this.settings.triggers.queryChange) {\r\n            if (\r\n                query.queryText.trim().length >\r\n                this.settings.triggers.queryChangeMinLength\r\n            ) {\r\n                if (\r\n                    this.settings.triggers.queryChangeInstantRegex &&\r\n                    this.settings.triggers.queryChangeInstantRegex.test(\r\n                        query.queryText\r\n                    )\r\n                ) {\r\n                    this.update(query);\r\n                    return;\r\n                } else {\r\n                    if (this.settings.triggers.queryChangeDelay > -1) {\r\n                        this.update(\r\n                            query,\r\n                            this.settings.triggers.queryChangeDelay\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        clearTimeout(this.delay);\r\n    }\r\n\r\n    public searchTypeChanged(oldValue: SearchType, query: IQuery) {\r\n        if (!this.shouldUpdate(\"searchType\", query)) {\r\n            return;\r\n        }\r\n        if (this.settings.triggers.searchTypeChanged) {\r\n            this.update(query);\r\n        }\r\n    }\r\n\r\n    public uiLanguageCodeChanged(oldValue: string, query: IQuery) {\r\n        if (!this.shouldUpdate(\"uiLanguageCode\", query)) {\r\n            return;\r\n        }\r\n        if (this.settings.triggers.uiLanguageCodeChanged) {\r\n            this.update(query);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a Filter object based on the input id (string [] or Category).\r\n     *\r\n     * NB! This method does NOT apply the filter in the filters collection.\r\n     * It is used behind the scenes by the filter* methods in SearchClient.\r\n     * To apply a filter you need to use the filter* properties/methods in\r\n     * SearchClient.\r\n     *\r\n     * If the category doesn't exist then the filter\r\n     * will not be created.\r\n     *\r\n     * If passing in a string[] then the value is expected to match the categoryName\r\n     * property of a listed category.\r\n     *\r\n     * @param categoryName A string array or a Category that denotes the category to create a filter for.\r\n     */\r\n    public createCategoryFilter(categoryName: string[] | ICategory): Filter {\r\n        let catName = Array.isArray(categoryName)\r\n            ? categoryName\r\n            : categoryName.categoryName;\r\n        let result: string[] = [];\r\n        let path = catName.slice(0);\r\n        let groupId = path.splice(0, 1)[0].toLowerCase();\r\n\r\n        if (\r\n            !this.categories ||\r\n            !this.categories.groups ||\r\n            this.categories.groups.length === 0\r\n        ) {\r\n            return null;\r\n        }\r\n\r\n        let group = this.categories.groups.find(\r\n            g => g.name.toLowerCase() === groupId\r\n        );\r\n\r\n        if (!group) {\r\n            return null;\r\n        }\r\n\r\n        result.push(group.displayName);\r\n\r\n        if (group.categories.length > 0) {\r\n            let {\r\n                displayName,\r\n                ref\r\n            } = this.getCategoryPathDisplayNameFromCategories(\r\n                path,\r\n                group.categories\r\n            );\r\n            if (displayName && displayName.length > 0) {\r\n                result = result.concat(displayName);\r\n                return new Filter(result, ref);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find the category based on the category-name array.\r\n     *\r\n     * @param categoryName The category array that identifies the category.\r\n     * @returns The Category object if found or null.\r\n     */\r\n    public findCategory(\r\n        categoryName: string[],\r\n        categories?: ICategories\r\n    ): IGroup | ICategory | null {\r\n        categories = categories || this.categories;\r\n        if (!categories) {\r\n            return null;\r\n        }\r\n        let groupIndex = categories.groups.findIndex(\r\n            g => g.name === categoryName[0]\r\n        );\r\n        if (groupIndex < 0) {\r\n            return null;\r\n        }\r\n        let group = categories.groups[groupIndex];\r\n        if (categoryName.length === 1) {\r\n            return group;\r\n        }\r\n        let category = this.getCategoryPathDisplayNameFromCategories(\r\n            categoryName.slice(1),\r\n            group.categories\r\n        );\r\n\r\n        return category ? category.ref : null;\r\n    }\r\n\r\n    /**\r\n     * Adds missing filters as category-tree-nodes.\r\n     */\r\n    private addFiltersInTreeIfMissing(filters: Filter[], cats: ICategories) {\r\n        filters.forEach(f => {\r\n            if (f.hidden) {\r\n                return;\r\n            }\r\n            const depth = f.category.categoryName.length;\r\n            for (let i = 0; i < depth; i++) {\r\n                let categoryNames = f.category.categoryName.slice(0, i + 1);\r\n                if (!this.findCategory(categoryNames, cats)) {\r\n                    let displayName = f.displayName ? f.displayName[i] : categoryNames[categoryNames.length - 1];\r\n                    let parentCategoryNames = categoryNames.slice(0, -1);\r\n                    if (i === 0) {\r\n                        // Need to add group\r\n                        let group = {\r\n                            displayName,\r\n                            categories: [],\r\n                            expanded: false,\r\n                            name: categoryNames[0]\r\n                        } as IGroup;\r\n                        cats.groups.push(group);\r\n                    } else {\r\n                        // Need to add child category\r\n                        let parent = this.findCategory(\r\n                            parentCategoryNames,\r\n                            cats\r\n                        );\r\n                        if (!parent) {\r\n                            throw Error(\r\n                                \"Since we are iterating from groups and outwards this should not happen.\"\r\n                            );\r\n                        }\r\n                        let category =\r\n                            i === depth - 1\r\n                                ? // Since we are on the last element we can add the category within the filter directly\r\n                                  {\r\n                                      ...{ children: [], displayName},\r\n                                      ...f.category,\r\n                                      ...{ count: 0, expanded: false }\r\n                                  }\r\n                                : // Not at the leaf-node yet.\r\n                                  ({\r\n                                      categoryName: categoryNames,\r\n                                      children: [],\r\n                                      count: 0,\r\n                                      expanded: false,\r\n                                      displayName,\r\n                                      name: categoryNames[i]\r\n                                  } as ICategory);\r\n\r\n                        // Since the parent has a child, set the node to be expanded.\r\n                        parent.expanded = true;\r\n\r\n                        // Add the child-category to the parent-node\r\n                        if (i === 1) {\r\n                            // Parent is a group\r\n                            (parent as IGroup).categories.push(category);\r\n                        } else {\r\n                            // Parent is a category\r\n                            (parent as ICategory).children.push(category);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private filterCategories(\r\n        categories: ICategories,\r\n        query: IQuery = new Query()\r\n    ): ICategories {\r\n        // ROOT level adjustments\r\n        let cats = { ...categories };\r\n        let rootOverride = this.settings.presentations.__ROOT__;\r\n        if (rootOverride) {\r\n            if (\r\n                rootOverride.group &&\r\n                rootOverride.group.enabled &&\r\n                cats.groups.length >= rootOverride.group.minCount\r\n            ) {\r\n                // Add level of categories to group according to pattern\r\n                cats.groups = this.grouping(rootOverride, cats.groups);\r\n            }\r\n            if (rootOverride.filter && rootOverride.filter.enabled) {\r\n                cats.groups = this.filtering(rootOverride, cats.groups);\r\n            }\r\n            if (rootOverride.sort && rootOverride.sort.enabled) {\r\n                // Reorder level\r\n                cats.groups = this.sorting(rootOverride, cats.groups);\r\n            }\r\n            if (rootOverride.limit && rootOverride.limit.enabled) {\r\n                // Limit which categories to show\r\n                cats.groups = this.limiting(cats.groups, rootOverride.limit);\r\n            }\r\n            // Skipping expansion, as root is always expanded\r\n        }\r\n        const hiddenFilters: Filter[] = query.filters ? query.filters.filter(f => f.hidden) : [];\r\n\r\n        // GROUP-level adjustments\r\n        let groups = cats.groups.map((inGroup: IGroup) => {\r\n            let group = { ...inGroup };\r\n\r\n            // Iterate filters that have only the group-level set\r\n            let hiddenFiltersInGroup = hiddenFilters.filter(f => f.category.categoryName.length > 0 && f.category.categoryName[0] === group.name);\r\n            let match = hiddenFiltersInGroup.find(f => f.category.categoryName.length === 1);\r\n            if (match) {\r\n                // The hidden filter is for this group exactly. So, remove the group\r\n                return null;\r\n            }\r\n\r\n            let groupOverride = this.settings.presentations[group.name];\r\n            if (groupOverride) {\r\n                if (\r\n                    groupOverride.group &&\r\n                    groupOverride.group.enabled &&\r\n                    group.categories.length >= groupOverride.group.minCount\r\n                ) {\r\n                    // Add level of categories to group according to pattern\r\n                    group.categories = this.grouping(\r\n                        groupOverride,\r\n                        group.categories\r\n                    );\r\n                }\r\n                if (groupOverride.filter && groupOverride.filter.enabled) {\r\n                    group.categories = this.filtering(\r\n                        groupOverride,\r\n                        group.categories\r\n                    );\r\n                }\r\n                if (groupOverride.sort && groupOverride.sort.enabled) {\r\n                    // Reorder level\r\n                    group.categories = this.sorting(\r\n                        groupOverride,\r\n                        group.categories\r\n                    );\r\n                }\r\n                if (groupOverride.limit && groupOverride.limit.enabled) {\r\n                    // Limit which categories to show\r\n                    group.categories = this.limiting(\r\n                        group.categories,\r\n                        groupOverride.limit\r\n                    );\r\n                }\r\n                if (groupOverride.expanded !== null) {\r\n                    // Override whether the group is to be expanded or not\r\n                    group.expanded = groupOverride.expanded;\r\n                }\r\n            }\r\n            if (group.categories && group.categories.length > 0) {\r\n                group.categories = this.mapCategories(group.categories, hiddenFiltersInGroup, 1); //.filter(c => c !== undefined && c !== null);\r\n            }\r\n            if ((!group.categories || group.categories.length === 0) && hiddenFiltersInGroup.length > 0) {\r\n                // If the group has no categories, due to hidden filters, then remove the group itself\r\n                return null;\r\n            }\r\n            return group;\r\n        });\r\n        cats.groups = groups.filter(g => g !== undefined && g !== null);\r\n        this.addFiltersInTreeIfMissing(query.filters, cats);\r\n        return cats;\r\n    }\r\n\r\n    private mapCategories(categories: ICategory[], hiddenFilters: Filter[], depth: number): ICategory[] {\r\n        // CATEGORY_level adjustments\r\n        let cats = [...categories];\r\n        cats = cats.map((inCategory: ICategory) => {\r\n            let category = { ...inCategory };\r\n\r\n            // Iterate filters that have only the group-level set\r\n            let hiddenFiltersInCategory = hiddenFilters.filter(f => f.category.categoryName.length > depth && f.category.categoryName[depth] === category.name);\r\n            if (hiddenFiltersInCategory.find(f => f.category.categoryName.length === depth + 1)) {\r\n                // The hidden filter is for this category exactly. So, remove the category\r\n                return null;\r\n            }\r\n\r\n            if (category.categoryName == null) {\r\n                console.warn(`HAIVE/search-client: Illegal category-object received. The categoryName array cannot be null. The category was not added to the category-tree.`, category);\r\n                return null;\r\n            }\r\n\r\n            let categoryOverride = this.settings.presentations[\r\n                category.categoryName.join(\"|\")\r\n            ];\r\n            if (categoryOverride) {\r\n                if (\r\n                    categoryOverride.group &&\r\n                    categoryOverride.group.enabled &&\r\n                    category.children.length >= categoryOverride.group.minCount\r\n                ) {\r\n                    category.children = this.grouping(\r\n                        categoryOverride,\r\n                        category.children\r\n                    );\r\n                }\r\n                if (\r\n                    categoryOverride.filter &&\r\n                    categoryOverride.filter.enabled\r\n                ) {\r\n                    category.children = this.filtering(\r\n                        categoryOverride,\r\n                        category.children\r\n                    );\r\n                }\r\n                if (categoryOverride.sort && categoryOverride.sort.enabled) {\r\n                    category.children = this.sorting(\r\n                        categoryOverride,\r\n                        category.children\r\n                    );\r\n                }\r\n                if (categoryOverride.limit && categoryOverride.limit.enabled) {\r\n                    category.children = this.limiting(\r\n                        category.children,\r\n                        categoryOverride.limit\r\n                    );\r\n                }\r\n                if (categoryOverride.expanded !== null) {\r\n                    category.expanded = categoryOverride.expanded;\r\n                }\r\n            }\r\n            if (category.children && category.children.length > 0) {\r\n                category.children = this.mapCategories(category.children, hiddenFilters, depth++);\r\n            }\r\n            if ((!category.children || category.children.length === 0) && hiddenFiltersInCategory.length > 0) {\r\n                // If the category has no children, due to hidden filters, then remove the category itself\r\n                return null;\r\n            }\r\n\r\n            return category;\r\n        });\r\n\r\n        cats = cats.filter(c => c !== undefined && c !== null);\r\n        return cats;\r\n    }\r\n    private grouping<T extends IGroup | ICategory>(\r\n        categoryOverride: CategoryPresentation,\r\n        categories: T[]\r\n    ): T[] {\r\n        let matchCategories: Map<string, ICategory[]> = new Map<\r\n            string,\r\n            ICategory[]\r\n        >();\r\n\r\n        let category2MatchCategory: Map<string, string> = new Map<\r\n            string,\r\n            string\r\n        >();\r\n\r\n        // Iterate, map and count to check whether or not to group results.\r\n        let isCategory: boolean;\r\n        for (let c of categories) {\r\n            let groupName = categoryOverride.group.getMatch(c.displayName);\r\n            if (!groupName) {\r\n                continue;\r\n            }\r\n\r\n            isCategory = c.hasOwnProperty(\"count\");\r\n            let newNode: ICategory = isCategory\r\n                ? (c as ICategory)\r\n                : {\r\n                      categoryName: [c.name],\r\n                      children: (c as IGroup).categories,\r\n                      // We are really not sure what the real count is, as the category-hits may or may not be referring to the same items\r\n                      // -1 should indicate \"do not show\"\r\n                      count: -1,\r\n                      displayName: c.displayName,\r\n                      expanded: c.expanded,\r\n                      name: c.name\r\n                  };\r\n\r\n            if (!matchCategories.has(groupName)) {\r\n                matchCategories.set(groupName, [newNode]);\r\n            } else {\r\n                let collection = matchCategories.get(groupName);\r\n                collection.push(newNode);\r\n                matchCategories.set(groupName, collection);\r\n            }\r\n            category2MatchCategory.set(c.displayName, groupName);\r\n        }\r\n\r\n        // Do actual re-mapping, if any\r\n        return categories\r\n            .map(c => {\r\n                let displayName = category2MatchCategory.get(c.displayName);\r\n                if (!displayName) {\r\n                    // Done before\r\n                    return undefined;\r\n                }\r\n                let matchCategory = matchCategories.get(displayName);\r\n                if (!matchCategory) {\r\n                    return c;\r\n                }\r\n                if (\r\n                    matchCategory.length >=\r\n                    categoryOverride.group.minCountPerGroup\r\n                ) {\r\n                    let newCategory = {\r\n                        name: `__${displayName}__`,\r\n                        children: matchCategory,\r\n                        displayName,\r\n                        expanded: true,\r\n                        categoryName: [`__${displayName}__`]\r\n                    } as T;\r\n                    if (isCategory) {\r\n                        (newCategory as ICategory).count = -1;\r\n                    }\r\n\r\n                    matchCategory.forEach(i => {\r\n                        category2MatchCategory.delete(i.displayName);\r\n                    });\r\n                    return newCategory;\r\n                } else {\r\n                    return c;\r\n                }\r\n            })\r\n            .filter(c => c !== undefined && c !== null);\r\n    }\r\n\r\n    private filtering<T extends IGroup | ICategory>(\r\n        override: CategoryPresentation,\r\n        groups: T[]\r\n    ): T[] {\r\n        return groups.filter(g => {\r\n            if (override.filter.match) {\r\n                let matchName =\r\n                    override.filter.matchMode === MatchMode.DisplayName\r\n                        ? g.displayName\r\n                        : g.name;\r\n                return override.filter.match.test(matchName);\r\n            }\r\n        });\r\n    }\r\n\r\n    private sorting<T extends ICategory | IGroup>(\r\n        categoryOverride: CategoryPresentation,\r\n        categories: T[]\r\n    ): T[] {\r\n        // 1. Create parts2group-map\r\n        let part2cats = new Map<SortPartConfiguration, T[]>();\r\n        for (let p of categoryOverride.sort.parts) {\r\n            part2cats.set(p, []);\r\n        }\r\n\r\n        let other = new Array<T>();\r\n        let stringMatches = categoryOverride.sort.parts.filter(\r\n            p => typeof p.match === \"string\"\r\n        );\r\n        let regexMatches = categoryOverride.sort.parts.filter(\r\n            p => typeof p.match === \"object\"\r\n        );\r\n\r\n        for (let c of categories) {\r\n            let found = false;\r\n            for (let stringPart of stringMatches) {\r\n                if (\r\n                    stringPart.match ===\r\n                    (stringPart.matchMode === MatchMode.DisplayName\r\n                        ? c.displayName\r\n                        : c.name)\r\n                ) {\r\n                    let collection = part2cats.get(stringPart);\r\n                    collection.push(c);\r\n                    part2cats.set(stringPart, collection);\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (found) {\r\n                continue;\r\n            }\r\n            for (let regexPart of regexMatches) {\r\n                if (\r\n                    (regexPart.match as RegExp).test(\r\n                        regexPart.matchMode === MatchMode.DisplayName\r\n                            ? c.displayName\r\n                            : c.name\r\n                    )\r\n                ) {\r\n                    let collection = part2cats.get(regexPart);\r\n                    collection.push(c);\r\n                    part2cats.set(regexPart, collection);\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                other.push(c);\r\n            }\r\n        }\r\n\r\n        // 2. Sort each part\r\n        let sortedCats = new Array<T>();\r\n        part2cats.forEach((cs, p) => {\r\n            if (cs.length === 1) {\r\n                sortedCats = sortedCats.concat(cs);\r\n                return;\r\n            }\r\n            let res = new Array<T>();\r\n\r\n            switch (p.sortMethod) {\r\n                case SortMethod.AlphaAsc:\r\n                    res = cs.sort((a, b) => {\r\n                        let aVal =\r\n                            p.matchMode === MatchMode.DisplayName\r\n                                ? a.displayName\r\n                                : a.name;\r\n                        let bVal =\r\n                            p.matchMode === MatchMode.DisplayName\r\n                                ? b.displayName\r\n                                : b.name;\r\n                        return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;\r\n                    });\r\n                    break;\r\n\r\n                case SortMethod.AlphaDesc:\r\n                    res = cs.sort((a, b) => {\r\n                        let aVal =\r\n                            p.matchMode === MatchMode.DisplayName\r\n                                ? a.displayName\r\n                                : a.name;\r\n                        let bVal =\r\n                            p.matchMode === MatchMode.DisplayName\r\n                                ? b.displayName\r\n                                : b.name;\r\n                        return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;\r\n                    });\r\n                    break;\r\n\r\n                case SortMethod.CountAsc:\r\n                    if (cs[0].hasOwnProperty(\"count\")) {\r\n                        res = (cs as ICategory[]).sort((a, b) => {\r\n                            return a.count < b.count\r\n                                ? -1\r\n                                : a.count > b.count\r\n                                    ? 1\r\n                                    : 0;\r\n                        }) as T[];\r\n                    } else {\r\n                        res = cs;\r\n                    }\r\n                    break;\r\n                case SortMethod.CountDesc:\r\n                    if (cs[0].hasOwnProperty(\"count\")) {\r\n                        res = (cs as ICategory[]).sort((a, b) => {\r\n                            return a.count > b.count\r\n                                ? -1\r\n                                : a.count < b.count\r\n                                    ? 1\r\n                                    : 0;\r\n                        }) as T[];\r\n                    } else {\r\n                        res = cs;\r\n                    }\r\n                    break;\r\n                case SortMethod.Original:\r\n                default:\r\n                    // Keep order unchanged\r\n                    res = cs;\r\n            }\r\n\r\n            sortedCats = sortedCats.concat(res);\r\n        });\r\n\r\n        // Finally add any leftovers at the bottom\r\n        return sortedCats.concat(other);\r\n    }\r\n\r\n    private limiting(array: any[], limit: LimitPageConfiguration): any[] {\r\n        let from = (limit.page - 1) * limit.pageSize;\r\n        let to = from + limit.pageSize;\r\n        return array.slice(from, to);\r\n    }\r\n\r\n    private getCategoryPathDisplayNameFromCategories(\r\n        categoryName: string[],\r\n        categories: ICategory[]\r\n    ): { displayName: string[]; ref: ICategory } {\r\n        let result: string[] = [];\r\n        let path = categoryName.slice(0);\r\n        let catId = path.splice(0, 1)[0].toLowerCase();\r\n\r\n        let category = categories.find(c => c.name.toLowerCase() === catId);\r\n\r\n        if (!category) {\r\n            return null;\r\n        }\r\n\r\n        result.push(category.displayName);\r\n\r\n        let res: { displayName: string[]; ref: ICategory };\r\n        if (path.length > 0 && category.children.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (category.children.length > 0 && path.length > 0) {\r\n            res = this.getCategoryPathDisplayNameFromCategories(\r\n                path,\r\n                category.children\r\n            );\r\n            if (!res) {\r\n                return;\r\n            }\r\n            if (res.displayName && res.displayName.length > 0) {\r\n                result = result.concat(res.displayName);\r\n            }\r\n        }\r\n\r\n        return { displayName: result, ref: res ? res.ref : category };\r\n    }\r\n}\r\n"]}