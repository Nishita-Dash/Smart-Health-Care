import { AuthToken } from "../Authentication";
import { BaseCall, DateSpecification, Fetch, Filter, IQuery, SearchType, CategorizationType } from "../Common";
import { ICategories, ICategory, IGroup } from "../Data";
import { ICategorizeSettings } from "./CategorizeSettings";
/**
 * The Categorize service queries the search-engine for which categories that any
 * search-matches for the same query will contain.
 *
 * It is normally used indirectly via the SearchClient class.
 */
export declare class Categorize extends BaseCall<ICategories> {
    /**
     * This represents the last categories that was received from the backend.
     *
     * Note: Normally these are only used internally. You *can* however
     * populate these yourself, but if you are also executing fetches (which
     * the SearchClient is often doing in the automatic mode) then the contents
     * may be overwritten at any time.
     */
    categories: ICategories;
    settings: ICategorizeSettings;
    private queryConverter;
    /**
     * Creates a Categorize instance that handles fetching categories dependent on settings and query.
     * Supports registering a callback in order to receive categories when they have been received.
     * @param settings - The settings that define how the Categorize instance is to operate.
     * @param auth - An object that handles the authentication.
     */
    constructor(settings?: ICategorizeSettings | string, auth?: AuthToken, fetchMethod?: Fetch);
    /**
     * Fetches the search-result categories from the server.
     * @param query - The query-object that controls which results that are to be returned.
     * @param suppressCallbacks - Set to true if you have defined callbacks, but somehow don't want them to be called.
     * @returns a promise that when resolved returns a Categories object.
     */
    fetch(query?: IQuery, suppressCallbacks?: boolean): Promise<ICategories>;
    clientCategoriesUpdate(query: IQuery): void;
    categorizationTypeChanged(oldValue: CategorizationType, query: IQuery): void;
    clientIdChanged(oldValue: string, query: IQuery): void;
    dateFromChanged(oldValue: DateSpecification, query: IQuery): void;
    dateToChanged(oldValue: DateSpecification, query: IQuery): void;
    filtersChanged(oldValue: Filter[], query: IQuery): void;
    queryTextChanged(oldValue: string, query: IQuery): void;
    searchTypeChanged(oldValue: SearchType, query: IQuery): void;
    uiLanguageCodeChanged(oldValue: string, query: IQuery): void;
    /**
     * Creates a Filter object based on the input id (string [] or Category).
     *
     * NB! This method does NOT apply the filter in the filters collection.
     * It is used behind the scenes by the filter* methods in SearchClient.
     * To apply a filter you need to use the filter* properties/methods in
     * SearchClient.
     *
     * If the category doesn't exist then the filter
     * will not be created.
     *
     * If passing in a string[] then the value is expected to match the categoryName
     * property of a listed category.
     *
     * @param categoryName A string array or a Category that denotes the category to create a filter for.
     */
    createCategoryFilter(categoryName: string[] | ICategory): Filter;
    /**
     * Find the category based on the category-name array.
     *
     * @param categoryName The category array that identifies the category.
     * @returns The Category object if found or null.
     */
    findCategory(categoryName: string[], categories?: ICategories): IGroup | ICategory | null;
    /**
     * Adds missing filters as category-tree-nodes.
     */
    private addFiltersInTreeIfMissing;
    private filterCategories;
    private mapCategories;
    private grouping;
    private filtering;
    private sorting;
    private limiting;
    private getCategoryPathDisplayNameFromCategories;
}
